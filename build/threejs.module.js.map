{"version":3,"file":"threejs.module.js","sources":["../src/pointer.js","../src/three.js","../src/cursors/neon/index.js","../src/tools/color.js","../src/glsl/psrdnoise3.glsl","../src/cursors/particles/index.js","../src/tools/canvasTexture.js","../src/glsl/psrdnoise2.glsl","../src/backgrounds/noisy-lines/index.js","../src/glsl/mat3-lookat.glsl","../src/glsl/mat4-compose.glsl","../src/backgrounds/butterflies/index.js","../src/backgrounds/swarm/index.js","../src/backgrounds/fishes/index.js"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Pointer helper\n * @author Kevin Levron <kevin.levron@gmail.com>\n */\nexport default function (params) {\n  const {\n    domElement,\n    onClick = () => {},\n    onEnter = () => {},\n    onMove = () => {},\n    onLeave = () => {},\n    onDragStart = () => {},\n    onDragMove = () => {},\n    onDragStop = () => {}\n  } = params\n\n  const position = new Vector2()\n  const nPosition = new Vector2()\n  const startPosition = new Vector2()\n  const lastPosition = new Vector2()\n  const delta = new Vector2()\n\n  const obj = { position, nPosition, hover: false, down: false, removeListeners }\n\n  addListeners()\n\n  return obj\n\n  function pointerClick (e) {\n    if (startPosition.distanceTo(position) < 20) {\n      // console.log('pointerClick')\n      updatePosition(e)\n      onClick({ position, nPosition })\n    }\n  }\n\n  function pointerEnter (e) {\n    // console.log('pointerEnter', e)\n    obj.hover = e.pointerType === 'mouse'\n    updatePosition(e)\n    onEnter({ position, nPosition })\n  }\n\n  function pointerDown (e) {\n    // console.log('pointerDown')\n    obj.down = true\n    updatePosition(e)\n    startPosition.copy(position)\n    lastPosition.copy(position)\n    onDragStart({ position, nPosition })\n  }\n\n  function pointerMove (e) {\n    // console.log('pointerMove')\n    updatePosition(e)\n    delta.copy(position).sub(lastPosition)\n    if (obj.down) {\n      onDragMove({ position, nPosition, startPosition, lastPosition, delta })\n    } else {\n      if (!obj.hover) obj.hover = true\n    }\n    onMove({ position, nPosition, startPosition, lastPosition, delta })\n    lastPosition.copy(position)\n  }\n\n  function pointerUp (e) {\n    // console.log('pointerUp')\n    obj.down = false\n    onDragStop()\n  }\n\n  function pointerLeave (e) {\n    // console.log('pointerLeave')\n    if (obj.down) {\n      obj.down = false\n      onDragStop()\n    }\n    obj.hover = false\n    onLeave()\n  }\n\n  function updatePosition (e) {\n    const rect = domElement.getBoundingClientRect()\n    position.x = e.clientX - rect.left\n    position.y = e.clientY - rect.top\n    nPosition.x = (position.x / rect.width) * 2 - 1\n    nPosition.y = -(position.y / rect.height) * 2 + 1\n  }\n\n  function addListeners () {\n    domElement.addEventListener('click', pointerClick)\n    domElement.addEventListener('pointerenter', pointerEnter)\n    domElement.addEventListener('pointerdown', pointerDown)\n    domElement.addEventListener('pointermove', pointerMove)\n    domElement.addEventListener('pointerup', pointerUp)\n    domElement.addEventListener('pointerleave', pointerLeave)\n  }\n\n  function removeListeners () {\n    domElement.removeEventListener('click', pointerClick)\n    domElement.removeEventListener('pointerenter', pointerEnter)\n    domElement.removeEventListener('pointerdown', pointerDown)\n    domElement.removeEventListener('pointermove', pointerMove)\n    domElement.removeEventListener('pointerup', pointerUp)\n    domElement.removeEventListener('pointerleave', pointerLeave)\n  }\n}\n","import {\n  AmbientLight,\n  DirectionalLight,\n  PerspectiveCamera,\n  PointLight,\n  Scene,\n  WebGLRenderer\n} from 'three'\n\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\n\nimport pointer from './pointer'\n\nexport default function (params) {\n  const options = {\n    el: null,\n    canvas: null,\n    eventsEl: null,\n    width: null,\n    height: null,\n    resize: true,\n    alpha: false,\n    antialias: false,\n    orbitControls: false,\n    init () {},\n    initCamera () {},\n    initScene () {},\n    afterResize () {},\n    beforeRender () {},\n    ...params\n  }\n\n  const three = {\n    renderer: null,\n    camera: null,\n    scene: null,\n    pointer: null,\n    width: 0,\n    height: 0,\n    wWidth: 0,\n    wHeight: 0,\n    clock: {\n      startTime: 0,\n      time: 0,\n      elapsed: 0\n    },\n    options\n  }\n\n  let render\n\n  let cameraCtrl\n\n  init()\n\n  return three\n\n  function init () {\n    let canvas\n    if (options.el) {\n      canvas = document.createElement('canvas')\n      options.el.appendChild(canvas)\n    } else if (options.canvas) {\n      canvas = options.canvas\n    } else {\n      throw new Error('Missing parameter : el or canvas is required')\n    }\n\n    options.init?.(three)\n\n    three.renderer = new WebGLRenderer({ canvas, alpha: options.alpha, antialias: options.antialias })\n    options.initRenderer?.(three)\n\n    three.camera = new PerspectiveCamera()\n    three.camera.position.z = 50\n    options.initCamera?.(three)\n\n    if (options.orbitControls) {\n      cameraCtrl = new OrbitControls(three.camera, options.eventsEl ?? three.renderer.domElement)\n      cameraCtrl.enableDamping = true\n      cameraCtrl.dampingFactor = 0.1\n      if (typeof options.orbitControls === 'object') {\n        Object.keys(options.orbitControls).forEach(key => {\n          cameraCtrl[key] = options.orbitControls[key]\n        })\n      }\n    }\n\n    resize()\n    if (options.resize && !options.width && !options.height) {\n      window.addEventListener('resize', resize)\n    }\n\n    three.scene = new Scene()\n    options.initScene?.(three)\n\n    initPointer()\n\n    render = options.render ? options.render : () => { three.renderer.render(three.scene, three.camera) }\n\n    requestAnimationFrame(timestamp => {\n      three.clock.startTime = three.clock.time = timestamp\n      requestAnimationFrame(animate)\n    })\n  }\n\n  function initPointer () {\n    const pointerOptions = {}\n    if (options.onPointerEnter) { pointerOptions.onEnter = options.onPointerEnter }\n    if (options.onPointerMove) { pointerOptions.onMove = options.onPointerMove }\n    if (options.onPointerMove) { pointerOptions.onLeave = options.onPointerLeave }\n    if (Object.keys(pointerOptions).length > 0) {\n      three.pointer = pointer({ domElement: options.eventsEl ?? (options.el ?? options.canvas), ...pointerOptions })\n    }\n  }\n\n  function animate (timestamp) {\n    const { clock } = three\n    clock.elapsed = timestamp - clock.time\n    clock.time = timestamp\n\n    options.beforeRender(three)\n\n    if (cameraCtrl) cameraCtrl.update()\n\n    render(three)\n    requestAnimationFrame(animate)\n  }\n\n  function resize () {\n    if (options.width && options.height) {\n      three.width = options.width\n      three.height = options.height\n    } else if (options.resize === 'window') {\n      three.width = window.innerWidth\n      three.height = window.innerHeight\n    } else {\n      const parent = three.renderer.domElement.parentElement\n      three.width = parent.clientWidth\n      three.height = parent.clientHeight\n    }\n\n    three.renderer.setSize(three.width, three.height)\n    three.camera.aspect = three.width / three.height\n    three.camera.updateProjectionMatrix()\n    if (three.camera instanceof PerspectiveCamera) {\n      const wsize = getCameraViewSize()\n      three.wWidth = wsize[0]; three.wHeight = wsize[1]\n    } else {\n      three.wWidth = three.camera.top - three.camera.bottom\n      three.wHeight = three.camera.right - three.camera.left\n    }\n    options.afterResize?.(three)\n  }\n\n  function getCameraViewSize () {\n    const vFOV = (three.camera.fov * Math.PI) / 180\n    const h = 2 * Math.tan(vFOV / 2) * Math.abs(three.camera.position.z)\n    const w = h * three.camera.aspect\n    return [w, h]\n  }\n}\n\nexport function commonConfig (params) {\n  const config = {}\n  const keys = ['el', 'canvas', 'eventsEl', 'width', 'height', 'resize', 'orbitControls']\n  keys.forEach(key => {\n    if (params[key] !== undefined) config[key] = params[key]\n  })\n  return config\n}\n\nexport function initLights (scene, lightsConfig) {\n  const lights = []\n  if (Array.isArray(lightsConfig) && lightsConfig.length > 0) {\n    let light\n    lightsConfig.forEach(lightConfig => {\n      switch (lightConfig.type) {\n        case 'ambient':\n          light = new AmbientLight(...lightConfig.params)\n          break\n        case 'directional':\n          light = new DirectionalLight(...lightConfig.params)\n          break\n        case 'point':\n          light = new PointLight(...lightConfig.params)\n          break\n        default:\n          console.error(`Unknown light type ${lightConfig.type}`)\n      }\n      if (light) {\n        if (typeof lightConfig.props === 'object') {\n          Object.keys(lightConfig.props).forEach(key => {\n            if (key === 'position') {\n              light.position.set(...lightConfig.props[key])\n            } else light[key] = lightConfig.props[key]\n          })\n        }\n        scene.add(light)\n        lights.push(light)\n      }\n    })\n  }\n  return lights\n}\n","import { Color, Mesh, OrthographicCamera, PlaneGeometry, ShaderMaterial, SplineCurve, Vector2, Vector3 } from 'three'\nimport three from '../../three'\n\nconst defaultConfig = {\n  shaderPoints: 8,\n  curvePoints: 80,\n  curveLerp: 0.75,\n  radius1: 3,\n  radius2: 5,\n  velocityTreshold: 10,\n  sleepRadiusX: 150,\n  sleepRadiusY: 150,\n  sleepTimeCoefX: 0.0025,\n  sleepTimeCoefY: 0.0025\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  const points = new Array(config.curvePoints).fill(0).map(() => new Vector2())\n  const spline = new SplineCurve(points)\n\n  const velocity = new Vector3()\n  const velocityTarget = new Vector3()\n\n  const uRatio = { value: new Vector2() }\n  const uSize = { value: new Vector2() }\n  const uPoints = { value: new Array(config.shaderPoints).fill(0).map(() => new Vector2()) }\n  const uColor = { value: new Color(0xff00ff) }\n\n  let material\n  let plane\n  let hover = false\n\n  const threeConfig = {}\n  const keys = ['el', 'canvas', 'width', 'height', 'resize']\n  keys.forEach(key => {\n    if (params[key] !== undefined) threeConfig[key] = params[key]\n  })\n\n  three({\n    ...threeConfig,\n    antialias: false,\n    initCamera (three) {\n      three.camera = new OrthographicCamera()\n    },\n    initScene ({ scene }) {\n      const geometry = new PlaneGeometry(2, 2)\n      material = new ShaderMaterial({\n        uniforms: { uRatio, uSize, uPoints, uColor },\n        defines: {\n          SHADER_POINTS: config.shaderPoints\n        },\n        vertexShader: `\n          varying vec2 vUv;\n          void main() {\n            vUv = uv;\n            gl_Position = vec4(position, 1.0);\n          }\n        `,\n        fragmentShader: `\n          // https://www.shadertoy.com/view/wdy3DD\n          // https://www.shadertoy.com/view/MlKcDD\n          // Signed distance to a quadratic bezier\n          float sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C) {\n            vec2 a = B - A;\n            vec2 b = A - 2.0*B + C;\n            vec2 c = a * 2.0;\n            vec2 d = A - pos;\n            float kk = 1.0 / dot(b,b);\n            float kx = kk * dot(a,b);\n            float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n            float kz = kk * dot(d,a);\n            float res = 0.0;\n            float p = ky - kx*kx;\n            float p3 = p*p*p;\n            float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n            float h = q*q + 4.0*p3;\n            if(h >= 0.0){\n              h = sqrt(h);\n              vec2 x = (vec2(h, -h) - q) / 2.0;\n              vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n              float t = uv.x + uv.y - kx;\n              t = clamp( t, 0.0, 1.0 );\n              // 1 root\n              vec2 qos = d + (c + b*t)*t;\n              res = length(qos);\n            } else {\n              float z = sqrt(-p);\n              float v = acos( q/(p*z*2.0) ) / 3.0;\n              float m = cos(v);\n              float n = sin(v)*1.732050808;\n              vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n              t = clamp( t, 0.0, 1.0 );\n              // 3 roots\n              vec2 qos = d + (c + b*t.x)*t.x;\n              float dis = dot(qos,qos);\n              res = dis;\n              qos = d + (c + b*t.y)*t.y;\n              dis = dot(qos,qos);\n              res = min(res,dis);\n              qos = d + (c + b*t.z)*t.z;\n              dis = dot(qos,qos);\n              res = min(res,dis);\n              res = sqrt( res );\n            }\n            return res;\n          }\n\n          uniform vec2 uRatio;\n          uniform vec2 uSize;\n          uniform vec2 uPoints[SHADER_POINTS];\n          uniform vec3 uColor;\n          varying vec2 vUv;\n          void main() {\n            float intensity = 1.0;\n            float radius = 0.015;\n\n            vec2 pos = (vUv - 0.5) * uRatio;\n\n            vec2 c = (uPoints[0] + uPoints[1]) / 2.0;\n            vec2 c_prev;\n            float dist = 10000.0;\n            for(int i = 0; i < SHADER_POINTS - 1; i++){\n              c_prev = c;\n              c = (uPoints[i] + uPoints[i + 1]) / 2.0;\n              dist = min(dist, sdBezier(pos, c_prev, uPoints[i], c));\n            }\n            dist = max(0.0, dist);\n\n            float glow = pow(uSize.y / dist, intensity);\n            vec3 col = vec3(0.0);\n            col += 10.0 * vec3(smoothstep(uSize.x, 0.0, dist));\n            col += glow * uColor;\n\n            // Tone mapping\n            col = 1.0 - exp(-col);\n            col = pow(col, vec3(0.4545));\n  \n            gl_FragColor = vec4(col, 1.0);\n          }\n        `\n      })\n      plane = new Mesh(geometry, material)\n      scene.add(plane)\n    },\n    afterResize ({ width, height }) {\n      uSize.value.set(config.radius1, config.radius2)\n      if (width >= height) {\n        uRatio.value.set(1, height / width)\n        uSize.value.multiplyScalar(1 / width)\n      } else {\n        uRatio.value.set(width / height, 1)\n        uSize.value.multiplyScalar(1 / height)\n      }\n    },\n    beforeRender ({ clock, width, height, wWidth }) {\n      for (let i = 1; i < config.curvePoints; i++) {\n        points[i].lerp(points[i - 1], config.curveLerp)\n      }\n      for (let i = 0; i < config.shaderPoints; i++) {\n        spline.getPoint(i / (config.shaderPoints - 1), uPoints.value[i])\n      }\n\n      if (!hover) {\n        const t1 = clock.time * config.sleepTimeCoefX\n        const t2 = clock.time * config.sleepTimeCoefY\n        const cos = Math.cos(t1)\n        const sin = Math.sin(t2)\n        const r1 = config.sleepRadiusX * wWidth / width\n        const r2 = config.sleepRadiusY * wWidth / width\n        const x = r1 * cos\n        const y = r2 * sin\n        spline.points[0].set(x, y)\n        uColor.value.r = 0.5 + 0.5 * Math.cos(clock.time * 0.0015)\n        uColor.value.g = 0\n        uColor.value.b = 1 - uColor.value.r\n      } else {\n        uColor.value.r = velocity.z\n        uColor.value.g = 0\n        uColor.value.b = 1 - velocity.z\n        velocity.multiplyScalar(0.95)\n      }\n    },\n    onPointerMove ({ nPosition, delta }) {\n      hover = true\n      const x = (0.5 * nPosition.x) * uRatio.value.x\n      const y = (0.5 * nPosition.y) * uRatio.value.y\n      spline.points[0].set(x, y)\n\n      velocityTarget.x = Math.min(velocity.x + Math.abs(delta.x) / config.velocityTreshold, 1)\n      velocityTarget.y = Math.min(velocity.y + Math.abs(delta.y) / config.velocityTreshold, 1)\n      velocityTarget.z = Math.sqrt(velocityTarget.x * velocityTarget.x + velocityTarget.y * velocityTarget.y)\n      velocity.lerp(velocityTarget, 0.05)\n    },\n    onPointerLeave () {\n      hover = false\n    }\n  })\n\n  return { config }\n}\n","import { Color } from 'three'\n\nexport function colorScale (colors) {\n  let range = []\n  setColors(colors)\n\n  const dummy = new Color()\n\n  return { setColors, getColorAt }\n\n  function setColors (colors) {\n    range = []\n    colors.forEach(color => {\n      range.push(new Color(color))\n    })\n  }\n\n  function getColorAt (progress) {\n    const p = Math.max(0, Math.min(1, progress)) * (colors.length - 1)\n    const i1 = Math.floor(p)\n    const c1 = range[i1]\n    if (i1 >= colors.length - 1) {\n      return c1.clone()\n    }\n    const p1 = p - i1\n    const c2 = range[i1 + 1]\n\n    dummy.r = c1.r + p1 * (c2.r - c1.r)\n    dummy.g = c1.g + p1 * (c2.g - c1.g)\n    dummy.b = c1.b + p1 * (c2.b - c1.b)\n    return dummy.clone()\n  }\n}\n","//\n// psrdnoise3.glsl\n//\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02, published under the MIT license (see below)\n//\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\n\n//\n// Periodic (tiling) 3-D simplex noise (tetrahedral lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n//\n// This is (yet) another variation on simplex noise. Unlike previous\n// implementations, the grid is axis-aligned to permit rectangular tiling.\n// The noise pattern can be made to tile seamlessly to any integer periods\n// up to 289 units in the x, y and z directions. Specifying a longer\n// period than 289 will result in errors in the noise field.\n//\n// This particular version of 3-D noise also implements animation by rotating\n// the generating gradient at each lattice point around a pseudo-random axis.\n// The rotating gradients give the appearance of a swirling motion, and\n// can serve a similar purpose for animation as motion along the fourth\n// dimension in 4-D noise. \n//\n// The rotating gradients in conjunction with the built-in ability to\n// compute exact analytic derivatives allow for \"flow noise\" effects\n// as presented by Ken Perlin and Fabrice Neyret.\n//\n\n// Use Perlin's rotated grid instead of the new tiling grid?\n// Enabling this adds about 1% to the execution time and\n// requires all periods to be multiples of 3. Other\n// integer periods can be specified, but when not evenly\n// divisible by 3, the actual period will be 3 times longer.\n// Take care not to overstep the maximum allowed period (288).\n//#define PERLINGRID\n\n// Enable faster gradient rotations?\n// Enabling this saves about 10% on execution time,\n// but the function will not run faster for alpha = 0.\n//#define FASTROTATION\n\n\n// Permutation polynomial for the hash value\nvec4 permute(vec4 x) {\n     vec4 xm = mod(x, 289.0);\n     return mod(((xm*34.0)+10.0)*xm, 289.0);\n}\n\n//\n// 3-D tiling simplex noise with rotating gradients and first order\n// analytical derivatives.\n// \"vec3 x\" is the point (x,y,z) to evaluate\n// \"vec3 period\" is the desired periods along x,y,z, up to 289.\n// (If Perlin's grid is used, multiples of 3 up to 288 are allowed.)\n// \"float alpha\" is the rotation (in radians) for the swirling gradients.\n// The \"float\" return value is the noise value, and\n// the \"out vec3 gradient\" argument returns the x,y,z partial derivatives.\n//\n// The function executes 15-20% faster if alpha is constant == 0.0\n// across all fragments being executed in parallel.\n// (This speedup will not happen if FASTROTATION is enabled. Do not specify\n// FASTROTATION if you are not actually going to use the rotation.)\n//\n// Setting any period to 0.0 or a negative value will skip the periodic\n// wrap for that dimension. Setting all periods to 0.0 makes the function\n// execute 10-15% faster.\n//\n// Not using the return value for the gradient will make the compiler\n// eliminate the code for computing it. This speeds up the function by\n// around 10%.\n//\nfloat psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)\n{\n\n#ifndef PERLINGRID\n  // Transformation matrices for the axis-aligned simplex grid\n  const mat3 M = mat3(0.0, 1.0, 1.0,\n                      1.0, 0.0, 1.0,\n                      1.0, 1.0, 0.0);\n\n  const mat3 Mi = mat3(-0.5, 0.5, 0.5,\n                        0.5,-0.5, 0.5,\n                        0.5, 0.5,-0.5);\n#endif\n\n  vec3 uvw;\n\n  // Transform to simplex space (tetrahedral grid)\n#ifndef PERLINGRID\n  // Use matrix multiplication, let the compiler optimise\n  uvw = M * x;\n#else\n  // Optimised transformation to uvw (slightly faster than\n  // the equivalent matrix multiplication on most platforms)\n  uvw = x + dot(x, vec3(1.0/3.0));\n#endif\n\n  // Determine which simplex we're in, i0 is the \"base corner\"\n  vec3 i0 = floor(uvw);\n  vec3 f0 = fract(uvw); // coords within \"skewed cube\"\n\n  // To determine which simplex corners are closest, rank order the\n  // magnitudes of u,v,w, resolving ties in priority order u,v,w,\n  // and traverse the four corners from largest to smallest magnitude.\n  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.\n  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison \"less-than\"\n  vec3 l_ = 1.0 - g_;             // complement is \"greater-or-equal\"\n  vec3 g = vec3(l_.z, g_.xy);\n  vec3 l = vec3(l_.xy, g_.z);\n  vec3 o1 = min( g, l );\n  vec3 o2 = max( g, l );\n\n  // Enumerate the remaining simplex corners\n  vec3 i1 = i0 + o1;\n  vec3 i2 = i0 + o2;\n  vec3 i3 = i0 + vec3(1.0);\n\n  vec3 v0, v1, v2, v3;\n\n  // Transform the corners back to texture space\n#ifndef PERLINGRID\n  v0 = Mi * i0;\n  v1 = Mi * i1;\n  v2 = Mi * i2;\n  v3 = Mi * i3;\n#else\n  // Optimised transformation (mostly slightly faster than a matrix)\n  v0 = i0 - dot(i0, vec3(1.0/6.0));\n  v1 = i1 - dot(i1, vec3(1.0/6.0));\n  v2 = i2 - dot(i2, vec3(1.0/6.0));\n  v3 = i3 - dot(i3, vec3(1.0/6.0));\n#endif\n\n  // Compute vectors to each of the simplex corners\n  vec3 x0 = x - v0;\n  vec3 x1 = x - v1;\n  vec3 x2 = x - v2;\n  vec3 x3 = x - v3;\n\n  if(any(greaterThan(period, vec3(0.0)))) {\n    // Wrap to periods and transform back to simplex space\n    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);\n    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);\n    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);\n\t// Wrap to periods where specified\n\tif(period.x > 0.0) vx = mod(vx, period.x);\n\tif(period.y > 0.0) vy = mod(vy, period.y);\n\tif(period.z > 0.0) vz = mod(vz, period.z);\n    // Transform back\n#ifndef PERLINGRID\n    i0 = M * vec3(vx.x, vy.x, vz.x);\n    i1 = M * vec3(vx.y, vy.y, vz.y);\n    i2 = M * vec3(vx.z, vy.z, vz.z);\n    i3 = M * vec3(vx.w, vy.w, vz.w);\n#else\n    v0 = vec3(vx.x, vy.x, vz.x);\n    v1 = vec3(vx.y, vy.y, vz.y);\n    v2 = vec3(vx.z, vy.z, vz.z);\n    v3 = vec3(vx.w, vy.w, vz.w);\n    // Transform wrapped coordinates back to uvw\n    i0 = v0 + dot(v0, vec3(1.0/3.0));\n    i1 = v1 + dot(v1, vec3(1.0/3.0));\n    i2 = v2 + dot(v2, vec3(1.0/3.0));\n    i3 = v3 + dot(v3, vec3(1.0/3.0));\n#endif\n\t// Fix rounding errors\n    i0 = floor(i0 + 0.5);\n    i1 = floor(i1 + 0.5);\n    i2 = floor(i2 + 0.5);\n    i3 = floor(i3 + 0.5);\n  }\n\n  // Compute one pseudo-random hash value for each corner\n  vec4 hash = permute( permute( permute( \n              vec4(i0.z, i1.z, i2.z, i3.z ))\n            + vec4(i0.y, i1.y, i2.y, i3.y ))\n            + vec4(i0.x, i1.x, i2.x, i3.x ));\n\n  // Compute generating gradients from a Fibonacci spiral on the unit sphere\n  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio\n  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289\n  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation\n\n  vec4 Ct = cos(theta);\n  vec4 St = sin(theta);\n  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere\n\n  vec4 gx, gy, gz;\n\n  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis\n#ifdef FASTROTATION\n  // Fast algorithm, but without dynamic shortcut for alpha = 0\n  vec4 qx = St;         // q' = norm ( cross(s, n) )  on the equator\n  vec4 qy = -Ct; \n  vec4 qz = vec4(0.0);\n\n  vec4 px =  sz * qy;   // p' = cross(q, s)\n  vec4 py = -sz * qx;\n  vec4 pz = sz_prime;\n\n  psi += alpha;         // psi and alpha in the same plane\n  vec4 Sa = sin(psi);\n  vec4 Ca = cos(psi);\n\n  gx = Ca * px + Sa * qx;\n  gy = Ca * py + Sa * qy;\n  gz = Ca * pz + Sa * qz;\n#else\n  // Slightly slower algorithm, but with g = s for alpha = 0, and a\n  // useful conditional speedup for alpha = 0 across all fragments\n  if(alpha != 0.0) {\n    vec4 Sp = sin(psi);          // q' from psi on equator\n    vec4 Cp = cos(psi);\n\n    vec4 px = Ct * sz_prime;     // px = sx\n    vec4 py = St * sz_prime;     // py = sy\n    vec4 pz = sz;\n\n    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q')\n    vec4 qx = mix( Ctp*St, Sp, sz);\n    vec4 qy = mix(-Ctp*Ct, Cp, sz);\n    vec4 qz = -(py*Cp + px*Sp);\n\n    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes\n    vec4 Ca = vec4(cos(alpha));\n\n    gx = Ca * px + Sa * qx;\n    gy = Ca * py + Sa * qy;\n    gz = Ca * pz + Sa * qz;\n  }\n  else {\n    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient\n    gy = St * sz_prime;\n    gz = sz;  \n  }\n#endif\n\n  // Reorganize for dot products below\n  vec3 g0 = vec3(gx.x, gy.x, gz.x);\n  vec3 g1 = vec3(gx.y, gy.y, gz.y);\n  vec3 g2 = vec3(gx.z, gy.z, gz.z);\n  vec3 g3 = vec3(gx.w, gy.w, gz.w);\n\n  // Radial decay with distance from each simplex corner\n  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\n  w = max(w, 0.0);\n  vec4 w2 = w * w;\n  vec4 w3 = w2 * w;\n\n  // The value of the linear ramp from each of the corners\n  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));\n\n  // Multiply by the radial decay and sum up the noise value\n  float n = dot(w3, gdotx);\n\n  // Compute the first order partial derivatives\n  vec4 dw = -6.0 * w2 * gdotx;\n  vec3 dn0 = w3.x * g0 + dw.x * x0;\n  vec3 dn1 = w3.y * g1 + dw.y * x1;\n  vec3 dn2 = w3.z * g2 + dw.z * x2;\n  vec3 dn3 = w3.w * g3 + dw.w * x3;\n  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);\n\n  // Scale the return value to fit nicely into the range [-1,1]\n  return 39.5 * n;\n}","import {\n    AdditiveBlending,\n    BufferAttribute,\n    BufferGeometry,\n    Color,\n    HalfFloatType,\n    MathUtils,\n    Points,\n    ShaderMaterial,\n    Vector2,\n    SphereGeometry,\n    BackSide,\n    Mesh\n} from \"three\";\nimport {GPUComputationRenderer} from \"three/examples/jsm/misc/GPUComputationRenderer.js\";\nimport three from \"../../three\";\nimport {colorScale} from \"../../tools/color\";\nimport psrdnoise from \"../../glsl/psrdnoise3.glsl\";\n\nconst {randFloat: rnd, randFloatSpread: rndFS} = MathUtils;\n\nconst defaultConfig = {\n    gpgpuSize: 256,\n    centerColor:0x056C71,\n    edgeColor:0x003234,\n    colors: [0xF87A2C, 0xF87A2C, 0xF87A2C],\n    color: 0xF87A2C,\n    coordScale: 1.5,\n    noiseIntensity: 0.001,\n    noiseTimeCoef: 0.0001,\n    pointSize: 5,\n    pointDecay: 0.005,\n    sleepRadiusX: 250,\n    sleepRadiusY: 250,\n    sleepTimeCoefX: 0.001,\n    sleepTimeCoefY: 0.002,\n    hover: 0,\n    position:[{ x: 0, y: 0 }]\n};\n\nexport default function (params) {\n    const config = {...defaultConfig, ...params};\n\n    const WIDTH = config.gpgpuSize;\n    const COUNT = WIDTH * WIDTH;\n\n    let gpu;\n    let dtPosition, dtVelocity;\n    let velocityVariable, positionVariable;\n\n    const uTime = {value: 0};\n    const uCoordScale = {value: config.coordScale};\n    const uNoiseIntensity = {value: config.noiseIntensity};\n    const uPointSize = {value: config.pointSize};\n    const uPointDecay = {value: config.pointDecay};\n    const uColor = {value: new Color(config.color)};\n    const uMouse = {value: new Vector2()};\n    const uMouseDirection = {value: new Vector2()};\n    const uniforms = {uTime, uCoordScale, uNoiseIntensity, uPointSize, uPointDecay, uColor, uMouse, uMouseDirection};\n\n    let geometry, material, mesh;\n\n    let hover = config.hover;\n    const mouseTarget = new Vector2();\n\n    var mindex = 0;\n\n    const changes =  config.position;\n    let mchange = {x:0,y:-100}\n\n\n    three({\n        ...commonConfig(params),\n        alpha: true, // Enable transparency for the renderer\n        antialias: false,\n        initRenderer({renderer}) {\n            renderer.setClearColor(0x000000, 0); // Make the canvas background transparent\n            initGPU(renderer);\n        },\n        initScene({scene}) {\n            initParticles();\n            scene.background = null;\n            scene.add(mesh);\n\n        },\n        beforeRender({width, wWidth, wHeight, clock, pointer}) {\n            if (!hover) {\n\n                // Update mouseTarget based on the latest change\n                mouseTarget.x = mchange.x ?? 0;\n                mouseTarget.y = mchange.y ?? 0;\n\n            } else {\n                // When hovering, update the mouse target based on pointer position\n                mouseTarget.x = pointer.nPosition.x * 0.5 * wWidth;\n                mouseTarget.y = pointer.nPosition.y * 0.5 * wHeight;\n            }\n\n            // Smooth transition of mouse position with lerp\n            uMouse.value.lerp(mouseTarget, 0.05);\n\n            // Update the time and compute GPU operations\n            uTime.value = clock.time * config.noiseTimeCoef;\n            gpu.compute();\n            material.uniforms.texturePosition.value = gpu.getCurrentRenderTarget(positionVariable).texture;\n            material.uniforms.textureVelocity.value = gpu.getCurrentRenderTarget(velocityVariable).texture;\n            function handleWheel(event) {\n                event.preventDefault(); // Prevents page scroll\n                console.log(\"Wheel event fired\");\n            }\n        },\n\n        onPointerMove({delta}) {\n            //hover = true\n            uMouseDirection.value.copy(delta);\n            console.log(delta)\n        },\n        onPointerLeave() {\n            //hover = false\n        },\n        onWheel(event) {\n            // Debugging: Check if the event is firing\n\n        }\n    });\n\n\n\n    window.addEventListener('load', () => {\n        window.addEventListener('wheel', handleWheel, { passive: false });\n\n\n        function handleWheel(event) {\n            event.preventDefault();  // Prevent the default scroll behavior\n\n            const scrollAmount = event.deltaY;\n            console.log(\"Scroll amount (deltaY):\", scrollAmount);\n\n            if (scrollAmount > 0) {\n                // Scroll down, increment mindex\n                if (mindex < changes.length - 1) {\n                    mindex++;\n                }\n            } else if (scrollAmount < 0) {\n                // Scroll up, decrement mindex\n                if (mindex > 0) {\n                    mindex--;\n                }\n            }\n\n            console.log(\"Current mindex:\", mindex);\n\n            if (mindex >= 0 && mindex < changes.length) {\n                const change = changes[mindex];\n                mchange.x = change.x;\n                mchange.y = change.y;\n\n                console.log(mindex);\n\n                // Simulate a mousemove event at the new pixel coordinates\n                const moveEvent = new MouseEvent('mousemove', {\n                    clientX: change.x,  // X position in pixels\n                    clientY: change.y,  // Y position in pixels\n                });\n\n                // Dispatch the event to simulate the movement\n                document.dispatchEvent(moveEvent);\n            }\n        }\n\n    });\n    // Start the mouse movement simulation\n\n\n\n    return {config, uniforms};\n\n    /**\n     */\n    function initGPU(renderer) {\n        gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer);\n      /*  if (!renderer.capabilities.isWebGL2) {\n            gpu.setDataType(HalfFloatType);\n        }\n*/\n        dtPosition = gpu.createTexture();\n        dtVelocity = gpu.createTexture();\n        initTextures(dtPosition, dtVelocity);\n\n        velocityVariable = gpu.addVariable(\"textureVelocity\", `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform float uCoordScale;\n      uniform float uNoiseIntensity;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        if (pos.w < 0.0) {\n          vel.x = 0.0;\n          vel.y = 0.0;\n          vel.z = 0.0;\n        } else {\n          vec3 grad;\n          vec3 p = vec3(0.0);\n          float n = psrdnoise(pos.xyz * uCoordScale, p, uTime, grad);\n          vel.xyz += grad * uNoiseIntensity * pos.w;\n        }\n        gl_FragColor = vel;\n      }\n    `, dtVelocity);\n\n        positionVariable = gpu.addVariable(\"texturePosition\", `\n      uniform float uPointDecay;\n      uniform vec2 uMouse;\n      uniform vec2 uMouseDirection;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        if (pos.w < 0.0) { pos.w = vel.w; }\n        pos.w -= uPointDecay;\n        if (pos.w <= 0.0) {\n          pos.xy = uMouse.xy;\n          pos.z = 0.0;\n        } else {\n          pos.xyz += vel.xyz;\n        }\n        gl_FragColor = pos;\n      }\n    `, dtPosition);\n\n        gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);\n        gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);\n\n        Object.keys(uniforms).forEach(key => {\n            velocityVariable.material.uniforms[key] = uniforms[key];\n            positionVariable.material.uniforms[key] = uniforms[key];\n        });\n\n        const error = gpu.init();\n        if (error !== null) {\n            console.error(error);\n        }\n    }\n\n    /**\n     */\n    function initParticles() {\n        geometry = new BufferGeometry();\n        const positions = new Float32Array(COUNT * 3);\n        const uvs = new Float32Array(COUNT * 2);\n        const colors = new Float32Array(COUNT * 3);\n\n        for (let i = 0; i < COUNT * 3; i += 3) {\n            positions[i] = 0;\n            positions[i + 1] = 0;\n            positions[i + 2] = 0;\n        }\n\n        let index = 0;\n        for (let j = 0; j < WIDTH; j++) {\n            for (let i = 0; i < WIDTH; i++) {\n                uvs[index++] = i / (WIDTH - 1);\n                uvs[index++] = j / (WIDTH - 1);\n            }\n        }\n\n        const cscale = colorScale(config.colors);\n        for (let i = 0; i < COUNT * 3; i += 3) {\n            const color = cscale.getColorAt(Math.random());\n            colors[i] = color.r;\n            colors[i + 1] = color.g;\n            colors[i + 2] = color.b;\n        }\n\n        geometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n        geometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2));\n        geometry.setAttribute(\"color\", new BufferAttribute(colors, 3));\n\n        material = new ShaderMaterial({\n            blending: AdditiveBlending,\n            depthTest: false,\n            transparent: true,\n            vertexColors: true,\n            uniforms: {\n                texturePosition: {value: null},\n                textureVelocity: {value: null},\n                uPointSize,\n                uColor\n            },\n            vertexShader: `\n        uniform sampler2D texturePosition;\n        uniform sampler2D textureVelocity;\n        uniform float uPointSize;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying vec3 vCol;\n        void main() {\n          vCol = color;\n          vPos = texture2D(texturePosition, uv);\n          vVel = texture2D(textureVelocity, uv);\n          vec4 mvPosition = modelViewMatrix * vec4(vPos.xyz, 1.0);\n          // gl_PointSize = smoothstep(0.0, 2.0, vPos.w) * uPointSize;\n          gl_PointSize = vPos.w * (vVel.w + 0.5) * uPointSize;\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n            fragmentShader: `\n        uniform vec3 uColor;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying vec3 vCol;\n        void main() {\n          float dist = length(gl_PointCoord - 0.5);\n          if (dist > 0.5) discard;\n          // float a = smoothstep(0.0, 1.0, vPos.w);\n          gl_FragColor = vec4(mix(vCol, uColor, vPos.w), vPos.w);\n        }\n      `\n        });\n\n        mesh = new Points(geometry, material);\n        mesh.matrixAutoUpdate = false;\n        mesh.updateMatrix();\n    }\n\n    /**\n     */\n    function initTextures(texturePosition, textureVelocity) {\n        const posArray = texturePosition.image.data;\n        const velArray = textureVelocity.image.data;\n        for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n            posArray[k + 0] = rndFS(1);\n            posArray[k + 1] = rndFS(1);\n            posArray[k + 2] = -100000;\n            posArray[k + 3] = rnd(0.1, 1);\n\n            velArray[k + 0] = 0; // rndFS(0.2)\n            velArray[k + 1] = 0; // rndFS(0.2)\n            velArray[k + 2] = 0; // rndFS(0.2)\n            velArray[k + 3] = rnd(0.1, 1);\n        }\n    }\n}\n/**\n */\nfunction commonConfig(params) {\n    const config = {};\n    const keys = [\"el\", \"canvas\", \"width\", \"height\", \"resize\"];\n    keys.forEach(key => {\n        if (params[key] !== undefined) config[key] = params[key];\n    });\n    return config;\n}\n","import { CanvasTexture } from 'three'\n\nconst defaultConfig = {\n  width: 256,\n  height: 256\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  const canvas = document.createElement('canvas')\n  canvas.width = config.width\n  canvas.height = config.height\n\n  const ctx = canvas.getContext('2d')\n\n  const texture = new CanvasTexture(ctx.canvas)\n\n  return { canvas, ctx, texture }\n}\n","//\n// psrdnoise2.glsl\n//\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\n// and Ian McEwan (ijm567@gmail.com)\n// Version 2021-12-02, published under the MIT license (see below)\n//\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the \"Software\"),\n// to deal in the Software without restriction, including without limitation\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\n// and/or sell copies of the Software, and to permit persons to whom the\n// Software is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\n\n//\n// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n//\n// This is (yet) another variation on simplex noise. Unlike previous\n// implementations, the grid is axis-aligned and slightly stretched in\n// the y direction to permit rectangular tiling.\n// The noise pattern can be made to tile seamlessly to any integer period\n// in x and any even integer period in y. Odd periods may be specified\n// for y, but then the actual tiling period will be twice that number.\n//\n// The rotating gradients give the appearance of a swirling motion, and\n// can serve a similar purpose for animation as motion along z in 3-D\n// noise. The rotating gradients in conjunction with the analytic\n// derivatives allow for \"flow noise\" effects as presented by Ken\n// Perlin and Fabrice Neyret.\n//\n\n\n//\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\n// \"vec2 x\" is the point (x,y) to evaluate,\n// \"vec2 period\" is the desired periods along x and y, and\n// \"float alpha\" is the rotation (in radians) for the swirling gradients.\n// The \"float\" return value is the noise value, and\n// the \"out vec2 gradient\" argument returns the x,y partial derivatives.\n//\n// Setting either period to 0.0 or a negative value will skip the wrapping\n// along that dimension. Setting both periods to 0.0 makes the function\n// execute about 15% faster.\n//\n// Not using the return value for the gradient will make the compiler\n// eliminate the code for computing it. This speeds up the function\n// by 10-15%.\n//\n// The rotation by alpha uses one single addition. Unlike the 3-D version\n// of psrdnoise(), setting alpha == 0.0 gives no speedup.\n//\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient) {\n\n\t// Transform to simplex space (axis-aligned hexagonal grid)\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\n\n\t// Determine which simplex we're in, with i0 being the \"base\"\n\tvec2 i0 = floor(uv);\n\tvec2 f0 = fract(uv);\n\t// o1 is the offset in simplex space to the second corner\n\tfloat cmp = step(f0.y, f0.x);\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\n\n\t// Enumerate the remaining simplex corners\n\tvec2 i1 = i0 + o1;\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\n\n\t// Transform corners back to texture space\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\n\n\t// Compute vectors from v to each of the simplex corners\n\tvec2 x0 = x - v0;\n\tvec2 x1 = x - v1;\n\tvec2 x2 = x - v2;\n\n\tvec3 iu, iv;\n\tvec3 xw, yw;\n\n\t// Wrap to periods, if desired\n\tif(any(greaterThan(period, vec2(0.0)))) {\n\t\txw = vec3(v0.x, v1.x, v2.x);\n\t\tyw = vec3(v0.y, v1.y, v2.y);\n\t\tif(period.x > 0.0)\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\n\t\tif(period.y > 0.0)\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\n\t\t// Transform back to simplex space and fix rounding errors\n\t\tiu = floor(xw + 0.5*yw + 0.5);\n\t\tiv = floor(yw + 0.5);\n\t} else { // Shortcut if neither x nor y periods are specified\n\t\tiu = vec3(i0.x, i1.x, i2.x);\n\t\tiv = vec3(i0.y, i1.y, i2.y);\n\t}\n\n\t// Compute one pseudo-random hash value for each corner\n\tvec3 hash = mod(iu, 289.0);\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\n\n\t// Pick a pseudo-random angle and add the desired rotation\n\tvec3 psi = hash * 0.07482 + alpha;\n\tvec3 gx = cos(psi);\n\tvec3 gy = sin(psi);\n\n\t// Reorganize for dot products below\n\tvec2 g0 = vec2(gx.x,gy.x);\n\tvec2 g1 = vec2(gx.y,gy.y);\n\tvec2 g2 = vec2(gx.z,gy.z);\n\n\t// Radial decay with distance from each simplex corner\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\n\tw = max(w, 0.0);\n\tvec3 w2 = w * w;\n\tvec3 w4 = w2 * w2;\n\n\t// The value of the linear ramp from each of the corners\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\n\n\t// Multiply by the radial decay and sum up the noise value\n\tfloat n = dot(w4, gdotx);\n\n\t// Compute the first order partial derivatives\n\tvec3 w3 = w2 * w;\n\tvec3 dw = -8.0 * w3 * gdotx;\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\n\tgradient = 10.9 * (dn0 + dn1 + dn2);\n\n\t// Scale the return value to fit nicely into the range [-1,1]\n\treturn 10.9 * n;\n}","import { Mesh, PlaneGeometry, ShaderMaterial, Vector2 } from 'three'\nimport three from '../../three'\nimport useCanvasTexture from '../../tools/canvasTexture'\nimport psrdnoise from '../../glsl/psrdnoise2.glsl'\nimport { colorScale } from '../../tools/color'\n\nconst defaultConfig = {\n  colors: [0xffffff, 0x000000],\n  minStroke: 5,\n  maxStroke: 5,\n  timeCoef: 0.0005,\n  coordScale: 2,\n  displacementScale: 0.002,\n  mouseScale: 0.25,\n  mouseLerp: 0.025\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  const canvasTexture = useCanvasTexture({ width: 1, height: 4096 })\n  drawTexture()\n\n  const uniforms = {\n    uMap: { value: canvasTexture.texture },\n    uTime: { value: 0 },\n    uCoordScale: { value: config.coordScale },\n    uDisplacementScale: { value: config.displacementScale },\n    uMouse: { value: new Vector2() }\n  }\n\n  const geometry = new PlaneGeometry()\n\n  const material = new ShaderMaterial({\n    uniforms,\n    vertexShader: `\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    `,\n    fragmentShader: `\n      uniform sampler2D uMap;\n      uniform float uTime;\n      uniform float uCoordScale;\n      uniform float uDisplacementScale;\n      uniform vec2 uMouse;\n      varying vec2 vUv;\n      ${psrdnoise}\n      void main() {\n        vec2 p = vec2(0.0);\n        vec2 grad;\n        float n = psrdnoise(vUv * uCoordScale + uMouse, p, uTime, grad);\n        // grad *= uCoordScale;\n        vec2 uv = vUv + uDisplacementScale * grad;\n        gl_FragColor = texture2D(uMap, uv.yx);\n      }\n    `\n  })\n\n  const mesh = new Mesh(geometry, material)\n\n  const mouseTarget = new Vector2()\n\n  const threeConfig = {}\n  const keys = ['el', 'canvas', 'width', 'height', 'resize']\n  keys.forEach(key => {\n    if (params[key] !== undefined) threeConfig[key] = params[key]\n  })\n\n  three({\n    ...threeConfig,\n    antialias: true,\n    initScene ({ camera, scene, wWidth, wHeight }) {\n      mesh.scale.set(wWidth * 2, wHeight * 2, 1)\n      scene.add(mesh)\n\n      camera.position.set(0, -30, 7)\n      camera.lookAt(0, -19, 0)\n    },\n    beforeRender ({ clock }) {\n      uniforms.uTime.value = clock.time * config.timeCoef\n      uniforms.uMouse.value.lerp(mouseTarget, config.mouseLerp)\n    },\n    onPointerMove ({ nPosition }) {\n      mouseTarget.set(-nPosition.x, nPosition.y).multiplyScalar(config.mouseScale)\n    },\n    onPointerLeave () {\n      mouseTarget.set(0, 0)\n    }\n  })\n\n  return { config, uniforms, drawTexture }\n\n  function drawTexture () {\n    const ctx = canvasTexture.ctx\n    ctx.lineWidth = 0\n\n    const { width, height } = canvasTexture.canvas\n    const cscale = colorScale(config.colors)\n\n    let y = 0\n    let dy\n    while (y < height) {\n      dy = config.minStroke + Math.random() * (config.maxStroke - config.minStroke)\n\n      // ctx.strokeStyle = cscale.getColorAt(Math.random()).getStyle()\n      // ctx.lineWidth = dy + 1\n      // ctx.beginPath()\n      // ctx.moveTo(0, y + dy / 2)\n      // ctx.lineTo(width, y + dy / 2)\n      // ctx.stroke()\n      // ctx.closePath()\n\n      ctx.fillStyle = cscale.getColorAt(Math.random()).getStyle()\n      ctx.beginPath()\n      ctx.rect(0, y - 1, width, dy + 1)\n      ctx.fill()\n      ctx.closePath()\n\n      y += dy\n    }\n\n    canvasTexture.texture.needsUpdate = true\n  }\n}\n","mat3 lookAt(vec3 origin, vec3 target, vec3 up) {\n  vec3 z = target - origin;\n  if (z.x * z.x + z.y * z.y + z.z * z.z == 0.0) { z.z = 1.0; }\n  z = normalize(z);\n  vec3 x = cross(up, z);\n  if (x.x * x.x + x.y * x.y + x.z * x.z == 0.0) {\n    if (abs(up.z) == 1.0) { z.x += 0.0001; }\n    else { z.z += 0.0001; }\n    x = cross(up, z);\n  }\n  x = normalize(x);\n  vec3 y = cross(z, x);\n  return mat3(x, y, z);\n}\n","mat4 compose(vec3 pos, mat3 rmat, vec3 scale) {\n  return mat4(\n    rmat[0][0] * scale.x, rmat[0][1] * scale.x, rmat[0][2] * scale.x, 0.0,\n    rmat[1][0] * scale.y, rmat[1][1] * scale.y, rmat[1][2] * scale.y, 0.0,\n    rmat[2][0] * scale.z, rmat[2][1] * scale.z, rmat[2][2] * scale.z, 0.0,\n    pos.x, pos.y, pos.z, 1.0\n  );\n}\n","import { Color, DoubleSide, HalfFloatType, InstancedBufferAttribute, InstancedMesh, MathUtils, MeshBasicMaterial, MeshPhongMaterial, MeshStandardMaterial, PlaneGeometry, TextureLoader, Vector3 } from 'three'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'\n\nimport three, { commonConfig, initLights } from '../../three'\nimport psrdnoise from '../../glsl/psrdnoise3.glsl'\nimport mat3LookAt from '../../glsl/mat3-lookat.glsl'\nimport mat4Compose from '../../glsl/mat4-compose.glsl'\nimport { colorScale } from '../../tools/color'\n\nconst { randFloat: rnd, randFloatSpread: rndFS } = MathUtils\n\nconst defaultConfig = {\n  gpgpuSize: 64,\n  background: 0xffffff,\n  material: 'basic',\n  materialParams: {},\n  texture: null,\n  textureCount: 1,\n  colors: [0xffffff, 0xffffff],\n  lights: [\n    { type: 'ambient', params: [0xffffff, 0.5] },\n    { type: 'directional', params: [0xffffff, 1], props: { position: [0, 10, 0] } }\n  ],\n  wingsScale: [1, 1, 1],\n  wingsWidthSegments: 8,\n  wingsHeightSegments: 8,\n  wingsSpeed: 0.75,\n  wingsDisplacementScale: 1.25,\n  noiseCoordScale: 0.01,\n  noiseTimeCoef: 0.0005,\n  noiseIntensity: 0.0025,\n  attractionRadius1: 100,\n  attractionRadius2: 150,\n  maxVelocity: 0.1\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  if (!['basic', 'phong', 'standard'].includes(config.material)) {\n    throw new Error(`Invalid material ${config.material}`)\n  }\n\n  if (!Number.isInteger(config.wingsWidthSegments) || config.wingsWidthSegments % 2 !== 0) {\n    throw new Error(`Invalid wingsWidthSegments ${config.wingsWidthSegments}`)\n  }\n\n  const WIDTH = config.gpgpuSize\n  const COUNT = WIDTH * WIDTH\n\n  let gpu\n  let dtPosition, dtVelocity\n  let velocityVariable, positionVariable\n\n  const uTexturePosition = { value: null }\n  const uOldTexturePosition = { value: null }\n  const uTextureVelocity = { value: null }\n  const uTime = { value: 0 }\n  const uNoiseCoordScale = { value: config.noiseCoordScale }\n  const uNoiseIntensity = { value: config.noiseIntensity }\n  const uMaxVelocity = { value: config.maxVelocity }\n  const uAttractionRadius1 = { value: config.attractionRadius1 }\n  const uAttractionRadius2 = { value: config.attractionRadius2 }\n  const uWingsScale = { value: new Vector3(...config.wingsScale) }\n  const uWingsSpeed = { value: config.wingsSpeed }\n  const uWingsDisplacementScale = { value: config.wingsDisplacementScale }\n\n  const gpuTexturesUniforms = { uTexturePosition, uOldTexturePosition, uTextureVelocity }\n  const commonUniforms = { uTime, uNoiseCoordScale, uNoiseIntensity, uMaxVelocity, uAttractionRadius1, uAttractionRadius2, uWingsScale, uWingsSpeed, uWingsDisplacementScale }\n  const uniforms = { ...gpuTexturesUniforms, ...commonUniforms }\n\n  let geometry, material, iMesh\n\n  const _three = three({\n    ...commonConfig(params),\n    antialias: true,\n    orbitControls: true,\n    initRenderer ({ renderer }) {\n      initGPU(renderer)\n    },\n    initCamera ({ camera }) {\n      camera.position.set(0, 50, 70)\n    },\n    initScene ({ scene }) {\n      initScene(scene)\n    },\n    beforeRender ({ clock }) {\n      uTime.value = clock.time * config.noiseTimeCoef\n\n      gpu.compute()\n      uTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex].texture\n      uOldTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex === 0 ? 1 : 0].texture\n      uTextureVelocity.value = velocityVariable.renderTargets[gpu.currentTextureIndex].texture\n    }\n  })\n\n  return { three: _three, config, uniforms, setColors }\n\n  /**\n   */\n  function initGPU (renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer)\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType)\n    }\n\n    dtPosition = gpu.createTexture()\n    dtVelocity = gpu.createTexture()\n    initTextures(dtPosition, dtVelocity)\n\n    velocityVariable = gpu.addVariable('textureVelocity', `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      uniform float uMaxVelocity;\n      uniform float uAttractionRadius1;\n      uniform float uAttractionRadius2;\n      uniform float uWingsSpeed;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        vec3 grad;\n        float n = psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0), uTime, grad);\n        grad = grad * uNoiseIntensity;\n        vel.xyz = vel.xyz + (pos.w * 0.75) * grad;\n\n        vec3 dv = -pos.xyz;\n        float coef = smoothstep(uAttractionRadius1, uAttractionRadius2, length(dv));\n        vel.xyz = vel.xyz + pos.w * coef * normalize(dv);\n        vel.xyz = clamp(vel.xyz, -uMaxVelocity, uMaxVelocity);\n\n        vel.w = mod(vel.w + length(vel.xyz) * (0.5 + pos.w) * uWingsSpeed, 6.2831853071);\n        gl_FragColor = vel;\n      }\n    `, dtVelocity)\n\n    positionVariable = gpu.addVariable('texturePosition', `\n      ${psrdnoise}\n      uniform float uTime;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        pos.xyz += vel.xyz;\n        gl_FragColor = pos;\n      }\n    `, dtPosition)\n\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable])\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable])\n\n    Object.keys(commonUniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key]\n      positionVariable.material.uniforms[key] = uniforms[key]\n    })\n\n    const error = gpu.init()\n    if (error !== null) {\n      throw new Error(error)\n    }\n  }\n\n  /**\n   */\n  function initScene (scene) {\n    if (config.background !== undefined) {\n      scene.background = new Color(config.background)\n    }\n\n    initLights(scene, config.lights)\n\n    geometry = new PlaneGeometry(2, 2, config.wingsWidthSegments, config.wingsHeightSegments).rotateX(Math.PI / 2)\n\n    const gpuUvs = new Float32Array(COUNT * 2)\n    const mapIndexes = new Float32Array(COUNT)\n    let i1 = 0\n    let i2 = 0\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        gpuUvs[i1++] = i / (WIDTH - 1)\n        gpuUvs[i1++] = j / (WIDTH - 1)\n        mapIndexes[i2++] = Math.floor(Math.random() * config.textureCount)\n      }\n    }\n    geometry.setAttribute('gpuUv', new InstancedBufferAttribute(gpuUvs, 2))\n    geometry.setAttribute('mapIndex', new InstancedBufferAttribute(mapIndexes, 1))\n\n    const materialParams = { side: DoubleSide, ...config.materialParams }\n    if (config.texture) {\n      materialParams.map = new TextureLoader().load(config.texture)\n    }\n\n    materialParams.onBeforeCompile = shader => {\n      shader.defines = {\n        COMPUTE_NORMALS: config.material !== 'basic',\n        WINGS_WIDTH_SEGMENTS: config.wingsWidthSegments,\n        WINGS_HEIGHT_SEGMENTS: config.wingsHeightSegments,\n        WINGS_DX: (2.0 / config.wingsWidthSegments).toFixed(10),\n        WINGS_DZ: (2.0 / config.wingsHeightSegments).toFixed(10),\n        TEXTURE_COUNT: config.textureCount.toFixed(10)\n      }\n      Object.keys(uniforms).forEach(key => {\n        shader.uniforms[key] = uniforms[key]\n      })\n      shader.vertexShader = `\n        uniform sampler2D uTexturePosition;\n        uniform sampler2D uOldTexturePosition;\n        uniform sampler2D uTextureVelocity;\n        uniform vec3 uWingsScale;\n        uniform float uWingsDisplacementScale;\n        attribute vec2 gpuUv;\n        attribute float mapIndex;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying float vMapIndex;\n        ${mat3LookAt}\n        ${mat4Compose}\n      ` + shader.vertexShader\n      shader.vertexShader = shader.vertexShader.replace('#include <defaultnormal_vertex>', '')\n      shader.vertexShader = shader.vertexShader.replace('#include <normal_vertex>', '')\n      shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', `\n        vPos = texture2D(uTexturePosition, gpuUv);\n        vec4 oldPos = texture2D(uOldTexturePosition, gpuUv);\n        vVel = texture2D(uTextureVelocity, gpuUv);\n        vMapIndex = float(mapIndex);\n\n        mat3 rmat = lookAt(oldPos.xyz, vPos.xyz, vec3(0, 1, 0));\n        mat4 im = compose(vPos.xyz, rmat, (0.5 + vPos.w) * uWingsScale);\n\n        vec3 transformed = vec3(position);\n\n        #ifdef COMPUTE_NORMALS\n          vec3 transformedNormal = objectNormal; \n        #endif\n\n        float dx = abs(transformed.x);\n        if (dx > 0.0) {\n          float sdx = smoothstep(0.0, 1.0 + WINGS_DX, dx);\n          #if WINGS_HEIGHT_SEGMENTS > 1\n            float dz = transformed.z + 1.0;\n            float sdz = smoothstep(0.0, 2.0 + WINGS_DZ, dz);\n            transformed.y = sin(vVel.w - sdx + sdz) * sdx * uWingsDisplacementScale;\n          #else\n            transformed.y = sin(vVel.w - sdx) * sdx * uWingsDisplacementScale;\n          #endif\n\n          #ifdef COMPUTE_NORMALS\n            #if WINGS_HEIGHT_SEGMENTS > 1\n              float s = sign(transformed.x);\n              float sdx1 = smoothstep(0.0, 1.0 + WINGS_DX, dx + WINGS_DX);\n              float sdz1 = smoothstep(0.0, 2.0 + WINGS_DZ, dz + WINGS_DZ);\n              float dvy1 = sin(vVel.w - sdx + sdz1) * sdx * uWingsDisplacementScale - transformed.y;\n              float dvy2 = sin(vVel.w - sdx1 + sdz) * sdx1 * uWingsDisplacementScale - transformed.y;\n              vec3 v1 = vec3(0.0, dvy1, s * WINGS_DZ);\n              vec3 v2 = vec3(s * WINGS_DX, dvy2, 0.0);\n              transformedNormal = -normalize(cross(v1, v2));\n            #else\n              float s = sign(transformed.x);\n              float sdx1 = smoothstep(0.0, 1.0 + WINGS_DX, dx + WINGS_DX);\n              float dvy1 = sin(vVel.w - sdx1) * sdx * uWingsDisplacementScale - transformed.y;\n              vec3 v1 = vec3(0.0, 0.0, s);\n              vec3 v2 = vec3(s * WINGS_DX, dvy1, 0.0);\n              transformedNormal = -normalize(cross(v1, v2));\n            #endif  \n          #endif\n        }\n\n        #ifdef COMPUTE_NORMALS\n          #ifdef USE_INSTANCING\n            mat3 m = mat3( im );\n            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n            transformedNormal = m * transformedNormal;\n          #endif\n          transformedNormal = normalMatrix * transformedNormal;\n          #ifdef FLIP_SIDED\n            transformedNormal = - transformedNormal;\n          #endif\n          #ifdef USE_TANGENT\n            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n            #ifdef FLIP_SIDED\n              transformedTangent = - transformedTangent;\n            #endif\n          #endif\n          #ifndef FLAT_SHADED\n            vNormal = normalize( transformedNormal );\n            #ifdef USE_TANGENT\n              vTangent = normalize( transformedTangent );\n              vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n            #endif\n          #endif\n        #endif\n      `)\n\n      shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', `\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        #ifdef USE_INSTANCING\n          mvPosition = im * mvPosition;\n        #endif\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n      `)\n\n      shader.fragmentShader = `\n        varying float vMapIndex;\n      ` + shader.fragmentShader\n      shader.fragmentShader = shader.fragmentShader.replace('#include <map_fragment>', `\n        #ifdef USE_MAP\n          vec2 uv = vUv;\n          uv.x = (vMapIndex + vUv.x) / TEXTURE_COUNT;\n          vec4 sampledDiffuseColor = texture2D(map, uv);\n          diffuseColor *= sampledDiffuseColor;\n        #endif\n      `)\n    }\n\n    switch (config.material) {\n      case 'standard' :\n        material = new MeshStandardMaterial(materialParams)\n        break\n      case 'phong' :\n        material = new MeshPhongMaterial(materialParams)\n        break\n      default :\n        material = new MeshBasicMaterial(materialParams)\n    }\n\n    iMesh = new InstancedMesh(geometry, material, COUNT)\n    setColors(config.colors)\n    scene.add(iMesh)\n  }\n\n  function setColors (colors) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const cscale = colorScale(colors)\n      for (let i = 0; i < COUNT; i++) {\n        iMesh.setColorAt(i, cscale.getColorAt(i / COUNT))\n      }\n      iMesh.instanceColor.needsUpdate = true\n    }\n  }\n\n  /**\n   */\n  function initTextures (texturePosition, textureVelocity) {\n    const dummy = new Vector3()\n    const posArray = texturePosition.image.data\n    const velArray = textureVelocity.image.data\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      dummy.set(rndFS(1), rndFS(1), rndFS(1)).normalize().multiplyScalar(rndFS(config.attractionRadius1 * 2)).toArray(posArray, k)\n      posArray[k + 3] = rnd(0.1, 1)\n\n      dummy.set(rndFS(1), rndFS(1), rndFS(1)).normalize().multiplyScalar(rndFS(0.5)).toArray(velArray, k)\n      velArray[k + 3] = 0\n    }\n  }\n}\n","import { BoxGeometry, BufferGeometry, CapsuleGeometry, Color, ConeGeometry, DoubleSide, Float32BufferAttribute, HalfFloatType, InstancedBufferAttribute, InstancedMesh, MathUtils, MeshStandardMaterial, OctahedronGeometry, SphereGeometry, Vector2, Vector3 } from 'three'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js'\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js'\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js'\n\nimport three, { commonConfig, initLights } from '../../three'\nimport psrdnoise from '../../glsl/psrdnoise3.glsl'\nimport mat3LookAt from '../../glsl/mat3-lookat.glsl'\nimport mat4Compose from '../../glsl/mat4-compose.glsl'\nimport { colorScale } from '../../tools/color'\n\nconst { randFloat: rnd, randFloatSpread: rndFS } = MathUtils\n\nconst defaultConfig = {\n  gpgpuSize: 256,\n  bloomStrength: 1.5,\n  bloomRadius: 0.5,\n  bloomThreshold: 0.25,\n  colors: [Math.random() * 0xffffff, Math.random() * 0xffffff, Math.random() * 0xffffff],\n  geometry: 'custom',\n  geometryScale: [1, 1, 1],\n  lights: [\n    { type: 'ambient', params: [0xffffff, 0.5] },\n    { type: 'point', params: [0xffffff, 1], props: { position: [0, 0, 0] } },\n    { type: 'point', params: [0xff9060, 0.75], props: { position: [0, -100, -100] } },\n    { type: 'point', params: [0x6090ff, 0.75], props: { position: [0, 100, 100] } }\n  ],\n  materialParams: {},\n  noiseCoordScale: 0.01,\n  noiseIntensity: 0.0025,\n  noiseTimeCoef: 0.0004,\n  attractionRadius1: 150,\n  attractionRadius2: 250,\n  maxVelocity: 0.25\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  const WIDTH = config.gpgpuSize\n  const COUNT = WIDTH * WIDTH\n\n  let gpu\n  let dtPosition, dtVelocity\n  let velocityVariable, positionVariable\n\n  const uTexturePosition = { value: null }\n  const uOldTexturePosition = { value: null }\n  const uTextureVelocity = { value: null }\n  const uScale = { value: new Vector3(...config.geometryScale) }\n  const uTime = { value: 0 }\n  const uNoiseCoordScale = { value: config.noiseCoordScale }\n  const uNoiseIntensity = { value: config.noiseIntensity }\n  const uMaxVelocity = { value: config.maxVelocity }\n  const uAttractionRadius1 = { value: config.attractionRadius1 }\n  const uAttractionRadius2 = { value: config.attractionRadius2 }\n  const uMouse = { value: new Vector3() }\n\n  const gpuTexturesUniforms = { uTexturePosition, uOldTexturePosition, uTextureVelocity }\n  const commonUniforms = { uScale, uTime, uNoiseCoordScale, uNoiseIntensity, uMaxVelocity, uAttractionRadius1, uAttractionRadius2, uMouse }\n  const uniforms = { ...gpuTexturesUniforms, ...commonUniforms }\n\n  let effectComposer\n  let renderPass, bloomPass\n\n  let camera\n  let geometry, material, iMesh\n\n  // const mousePlane = new Plane(new Vector3(0, 0, 1), 0)\n  // const mousePosition = new Vector3()\n  // const raycaster = new Raycaster()\n\n  const _three = three({\n    ...commonConfig(params),\n    antialias: false,\n    orbitControls: true,\n    initRenderer ({ renderer }) {\n      initGPU(renderer)\n    },\n    initCamera (three) {\n      camera = three.camera\n      camera.position.z = 70\n    },\n    initScene ({ renderer, width, height, camera, scene }) {\n      initScene(scene)\n\n      renderPass = new RenderPass(scene, camera)\n      bloomPass = new UnrealBloomPass(new Vector2(width, height), config.bloomStrength, config.bloomRadius, config.bloomThreshold)\n      effectComposer = new EffectComposer(renderer)\n      effectComposer.addPass(renderPass)\n      effectComposer.addPass(bloomPass)\n    },\n    afterResize ({ width, height }) {\n      if (effectComposer) effectComposer.setSize(width, height)\n    },\n    beforeRender ({ clock }) {\n      uTime.value = clock.time * config.noiseTimeCoef\n      // uMouse.value.copy(mousePosition)\n\n      gpu.compute()\n      uTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex].texture\n      uOldTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex === 0 ? 1 : 0].texture\n      uTextureVelocity.value = velocityVariable.renderTargets[gpu.currentTextureIndex].texture\n    },\n    render () {\n      effectComposer.render()\n    }\n    // onPointerMove ({ nPosition }) {\n    //   raycaster.setFromCamera(nPosition, camera)\n    //   camera.getWorldDirection(mousePlane.normal)\n    //   raycaster.ray.intersectPlane(mousePlane, mousePosition)\n    // },\n    // onPointerLeave () {\n    //   mousePosition.set(0, 0, 0)\n    // }\n  })\n\n  return { three: _three, config, uniforms, setColors }\n\n  /**\n   */\n  function initGPU (renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer)\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType)\n    }\n\n    dtPosition = gpu.createTexture()\n    dtVelocity = gpu.createTexture()\n    initTextures(dtPosition, dtVelocity)\n\n    velocityVariable = gpu.addVariable('textureVelocity', `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform vec3 uMouse;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      uniform float uMaxVelocity;\n      uniform float uAttractionRadius1;\n      uniform float uAttractionRadius2;\n\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        vec3 grad;\n        float n = psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0), uTime, grad);\n        vel.xyz += (pos.w * 0.75) * grad * uNoiseIntensity;\n\n        vec3 dv = -pos.xyz;\n        float coef = smoothstep(uAttractionRadius1, uAttractionRadius2, length(dv));\n        vel.xyz = vel.xyz + pos.w * coef * normalize(dv);\n        vel.xyz = clamp(vel.xyz, -uMaxVelocity, uMaxVelocity);\n\n        gl_FragColor = vel;\n      }\n    `, dtVelocity)\n\n    positionVariable = gpu.addVariable('texturePosition', `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform vec3 uMouse;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        pos.xyz += vel.xyz;\n        gl_FragColor = pos;\n      }\n    `, dtPosition)\n\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable])\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable])\n\n    Object.keys(commonUniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key]\n      positionVariable.material.uniforms[key] = uniforms[key]\n    })\n\n    const error = gpu.init()\n    if (error !== null) {\n      throw new Error(error)\n    }\n  }\n\n  /**\n   */\n  function initScene (scene) {\n    if (config.background !== undefined) {\n      scene.background = new Color(config.background)\n    }\n\n    initLights(scene, config.lights)\n\n    switch (config.geometry) {\n      case 'box' :\n        geometry = new BoxGeometry()\n        break\n      case 'capsule' :\n        geometry = new CapsuleGeometry(0.2, 1, 4, 8).rotateX(Math.PI / 2)\n        break\n      case 'cone' :\n        geometry = new ConeGeometry(0.4, 2, 6).rotateX(Math.PI / 2)\n        break\n      case 'octahedron':\n        geometry = new OctahedronGeometry(1, 0).rotateX(Math.PI / 2)\n        break\n      case 'sphere' :\n        geometry = new SphereGeometry(0.5, 8, 8)\n        break\n      default:\n        geometry = customGeometry(1)\n    }\n\n    const gpuUvs = new Float32Array(COUNT * 2)\n    let index = 0\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        gpuUvs[index++] = i / (WIDTH - 1)\n        gpuUvs[index++] = j / (WIDTH - 1)\n      }\n    }\n    geometry.setAttribute('gpuUv', new InstancedBufferAttribute(gpuUvs, 2))\n\n    material = new MeshStandardMaterial({\n      metalness: 0.75,\n      roughness: 0.25,\n      side: DoubleSide,\n      ...config.materialParams,\n      onBeforeCompile: shader => {\n        Object.keys(uniforms).forEach(key => {\n          shader.uniforms[key] = uniforms[key]\n        })\n        shader.vertexShader = `\n          uniform sampler2D uTexturePosition;\n          uniform sampler2D uOldTexturePosition;\n          uniform sampler2D uTextureVelocity;\n          uniform vec3 uScale;\n          attribute vec2 gpuUv;\n          varying vec4 vPos;\n          varying vec4 vVel;\n          ${mat3LookAt}\n          ${mat4Compose}\n        ` + shader.vertexShader\n        shader.vertexShader = shader.vertexShader.replace('#include <defaultnormal_vertex>', `\n          vPos = texture2D(uTexturePosition, gpuUv);\n          vec4 oldPos = texture2D(uOldTexturePosition, gpuUv);\n          vVel = texture2D(uTextureVelocity, gpuUv);\n\n          mat3 rmat = lookAt(oldPos.xyz, vPos.xyz, vec3(0, 1, 0));\n          mat4 im = compose(vPos.xyz, rmat, (0.5 + vPos.w) * uScale);\n\n          vec3 transformedNormal = objectNormal;\n          mat3 m = mat3(im);\n          transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n          transformedNormal = m * transformedNormal;\n          transformedNormal = normalMatrix * transformedNormal;\n        `)\n        shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', `\n          vec4 mvPosition = modelViewMatrix * im * vec4(transformed, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n        `)\n      }\n    })\n\n    iMesh = new InstancedMesh(geometry, material, COUNT)\n    setColors(config.colors)\n    scene.add(iMesh)\n  }\n\n  /**\n   */\n  function setColors (colors) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const cscale = colorScale(colors)\n      for (let i = 0; i < COUNT; i++) {\n        iMesh.setColorAt(i, cscale.getColorAt(i / COUNT))\n      }\n      iMesh.instanceColor.needsUpdate = true\n    }\n  }\n\n  /**\n   */\n  function initTextures (texturePosition, textureVelocity) {\n    const dummy = new Vector3()\n    const posArray = texturePosition.image.data\n    const velArray = textureVelocity.image.data\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      dummy.set(rndFS(1), rndFS(1), rndFS(1)).normalize().multiplyScalar(rndFS(config.attractionRadius1 * 2)).toArray(posArray, k)\n      posArray[k + 3] = rnd(0.1, 1)\n\n      dummy.set(0, 0, 0).toArray(velArray, k)\n      velArray[k + 3] = 0\n    }\n  }\n}\n\nfunction customGeometry (size) {\n  const vertices = [\n    { p: [size * 0.5, 0, -size], n: [0, 1, 0] },\n    { p: [-size * 0.5, 0, -size], n: [0, 1, 0] },\n    { p: [0, 0, size], n: [0, 1, 0] },\n    { p: [0, -size * 0.5, -size], n: [1, 0, 0] },\n    { p: [0, size * 0.5, -size], n: [1, 0, 0] },\n    { p: [0, 0, size], n: [1, 0, 0] }\n  ]\n\n  const indexes = [0, 1, 2, 3, 4, 5]\n\n  const positions = []\n  const normals = []\n  for (const vertex of vertices) {\n    positions.push(...vertex.p)\n    normals.push(...vertex.n)\n  }\n\n  const geometry = new BufferGeometry()\n  geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n  geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n  geometry.setIndex(indexes)\n\n  return geometry\n}\n","import { Color, DoubleSide, FogExp2, HalfFloatType, InstancedBufferAttribute, InstancedMesh, MathUtils, MeshBasicMaterial, MeshPhongMaterial, MeshStandardMaterial, PlaneGeometry, TextureLoader, Vector3 } from 'three'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'\n\nimport three, { commonConfig, initLights } from '../../three'\nimport psrdnoise from '../../glsl/psrdnoise3.glsl'\nimport mat3LookAt from '../../glsl/mat3-lookat.glsl'\nimport mat4Compose from '../../glsl/mat4-compose.glsl'\nimport { colorScale } from '../../tools/color'\n\nconst { randFloat: rnd, randFloatSpread: rndFS } = MathUtils\n\nconst defaultConfig = {\n  gpgpuSize: 64,\n  background: 0xffffff,\n  material: 'basic',\n  materialParams: {},\n  texture: null,\n  textureCount: 1,\n  colors: [0xffffff, 0xffffff],\n  lights: [\n    { type: 'ambient', params: [0xffffff, 0.25] },\n    { type: 'directional', params: [0xffffff, 1], props: { position: [0, 0, 50] } }\n  ],\n  fogDensity: 0.01,\n  fishScale: [1, 1, 1],\n  fishWidthSegments: 8,\n  fishSpeed: 1.5,\n  fishDisplacementScale: 0.2,\n  noiseCoordScale: 0.01,\n  noiseTimeCoef: 0.0005,\n  noiseIntensity: 0.0025,\n  attractionRadius1: 50,\n  attractionRadius2: 100,\n  maxVelocity: 0.1\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  if (!['basic', 'phong', 'standard'].includes(config.material)) {\n    throw new Error(`Invalid material ${config.material}`)\n  }\n\n  if (!Number.isInteger(config.fishWidthSegments) || config.fishWidthSegments % 2 !== 0) {\n    throw new Error(`Invalid fishWidthSegments ${config.fishWidthSegments}`)\n  }\n\n  const WIDTH = config.gpgpuSize\n  const COUNT = WIDTH * WIDTH\n\n  let gpu\n  let dtPosition, dtVelocity\n  let velocityVariable, positionVariable\n\n  const uTexturePosition = { value: null }\n  const uOldTexturePosition = { value: null }\n  const uTextureVelocity = { value: null }\n  const uTime = { value: 0 }\n  const uNoiseCoordScale = { value: config.noiseCoordScale }\n  const uNoiseIntensity = { value: config.noiseIntensity }\n  const uMaxVelocity = { value: config.maxVelocity }\n  const uAttractionRadius1 = { value: config.attractionRadius1 }\n  const uAttractionRadius2 = { value: config.attractionRadius2 }\n  const uFishScale = { value: new Vector3(...config.fishScale) }\n  const uFishSpeed = { value: config.fishSpeed }\n  const uFishDisplacementScale = { value: config.fishDisplacementScale }\n\n  const gpuTexturesUniforms = { uTexturePosition, uOldTexturePosition, uTextureVelocity }\n  const commonUniforms = { uTime, uNoiseCoordScale, uNoiseIntensity, uMaxVelocity, uAttractionRadius1, uAttractionRadius2, uFishScale, uFishSpeed, uFishDisplacementScale }\n  const uniforms = { ...gpuTexturesUniforms, ...commonUniforms }\n\n  let geometry, material, iMesh\n\n  const _three = three({\n    ...commonConfig(params),\n    antialias: true,\n    orbitControls: true,\n    initRenderer ({ renderer }) {\n      initGPU(renderer)\n    },\n    initCamera ({ camera }) {\n      camera.position.set(0, 0, 70)\n    },\n    initScene ({ scene }) {\n      initScene(scene)\n    },\n    beforeRender ({ clock }) {\n      uTime.value = clock.time * config.noiseTimeCoef\n\n      gpu.compute()\n      uTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex].texture\n      uOldTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex === 0 ? 1 : 0].texture\n      uTextureVelocity.value = velocityVariable.renderTargets[gpu.currentTextureIndex].texture\n    }\n  })\n\n  return { three: _three, config, uniforms, setColors }\n\n  /**\n   */\n  function initGPU (renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer)\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType)\n    }\n\n    dtPosition = gpu.createTexture()\n    dtVelocity = gpu.createTexture()\n    initTextures(dtPosition, dtVelocity)\n\n    velocityVariable = gpu.addVariable('textureVelocity', `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      uniform float uMaxVelocity;\n      uniform float uAttractionRadius1;\n      uniform float uAttractionRadius2;\n      uniform float uFishSpeed;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        vec3 grad;\n        float n = psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0), uTime, grad);\n        grad = grad * uNoiseIntensity;\n        vel.xyz = vel.xyz + (pos.w * 0.75) * grad;\n\n        vec3 dv = -pos.xyz;\n        float coef = smoothstep(uAttractionRadius1, uAttractionRadius2, length(dv));\n        vel.xyz = vel.xyz + pos.w * coef * normalize(dv);\n        vel.xyz = clamp(vel.xyz, -uMaxVelocity, uMaxVelocity);\n\n        vel.w = mod(vel.w + length(vel.xyz) * (0.5 + pos.w) * uFishSpeed, 6.2831853071);\n        gl_FragColor = vel;\n      }\n    `, dtVelocity)\n\n    positionVariable = gpu.addVariable('texturePosition', `\n      ${psrdnoise}\n      uniform float uTime;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        pos.xyz += vel.xyz;\n        gl_FragColor = pos;\n      }\n    `, dtPosition)\n\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable])\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable])\n\n    Object.keys(commonUniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key]\n      positionVariable.material.uniforms[key] = uniforms[key]\n    })\n\n    const error = gpu.init()\n    if (error !== null) {\n      throw new Error(error)\n    }\n  }\n\n  /**\n   */\n  function initScene (scene) {\n    if (config.background !== undefined) {\n      scene.background = new Color(config.background)\n      if (config.fogDensity) scene.fog = new FogExp2(config.background, config.fogDensity)\n    }\n\n    initLights(scene, config.lights)\n\n    geometry = new PlaneGeometry(2, 1, config.fishWidthSegments, 1).rotateY(Math.PI / 2)\n\n    const gpuUvs = new Float32Array(COUNT * 2)\n    const mapIndexes = new Float32Array(COUNT)\n    let i1 = 0\n    let i2 = 0\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        gpuUvs[i1++] = i / (WIDTH - 1)\n        gpuUvs[i1++] = j / (WIDTH - 1)\n        mapIndexes[i2++] = Math.floor(Math.random() * config.textureCount)\n      }\n    }\n    geometry.setAttribute('gpuUv', new InstancedBufferAttribute(gpuUvs, 2))\n    geometry.setAttribute('mapIndex', new InstancedBufferAttribute(mapIndexes, 1))\n\n    const materialParams = { side: DoubleSide, ...config.materialParams }\n    if (config.texture) {\n      materialParams.map = new TextureLoader().load(config.texture)\n    }\n\n    materialParams.onBeforeCompile = shader => {\n      shader.defines = {\n        COMPUTE_NORMALS: config.material !== 'basic',\n        FISH_DZ: (2.0 / config.fishWidthSegments).toFixed(10),\n        TEXTURE_COUNT: config.textureCount.toFixed(10)\n      }\n      Object.keys(uniforms).forEach(key => {\n        shader.uniforms[key] = uniforms[key]\n      })\n      shader.vertexShader = `\n        uniform sampler2D uTexturePosition;\n        uniform sampler2D uOldTexturePosition;\n        uniform sampler2D uTextureVelocity;\n        uniform vec3 uFishScale;\n        uniform float uFishDisplacementScale;\n        attribute vec2 gpuUv;\n        attribute float mapIndex;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying float vMapIndex;\n        ${mat3LookAt}\n        ${mat4Compose}\n      ` + shader.vertexShader\n      shader.vertexShader = shader.vertexShader.replace('#include <defaultnormal_vertex>', '')\n      shader.vertexShader = shader.vertexShader.replace('#include <normal_vertex>', '')\n      shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', `\n        vPos = texture2D(uTexturePosition, gpuUv);\n        vec4 oldPos = texture2D(uOldTexturePosition, gpuUv);\n        vVel = texture2D(uTextureVelocity, gpuUv);\n        vMapIndex = float(mapIndex);\n\n        mat3 rmat = lookAt(oldPos.xyz, vPos.xyz, vec3(0, 1, 0));\n        mat4 im = compose(vPos.xyz, rmat, (0.5 + vPos.w) * uFishScale);\n\n        vec3 transformed = vec3(position);\n\n        #ifdef COMPUTE_NORMALS\n          vec3 transformedNormal = objectNormal; \n        #endif\n\n        float dz = transformed.z + 1.0;\n        float sdz = smoothstep(2.0, 0.0, dz);\n        transformed.x += sin(vVel.w + dz * PI * 1.5) * sdz * uFishDisplacementScale;\n\n        #ifdef COMPUTE_NORMALS\n          float dz1 = dz - 0.2;\n          float sdz1 = smoothstep(2.0, 0.0, dz1);\n          float dx1 = sin(vVel.w + dz1 * PI * 1.5) * sdz1 * uFishDisplacementScale - transformed.x;\n          vec3 v1 = vec3(dx1, 0.0, -FISH_DZ);\n          vec3 v2 = vec3(0.0, 1.0, 0.0);\n          transformedNormal = normalize(cross(v1, v2));\n        #endif\n\n        #ifdef COMPUTE_NORMALS\n          #ifdef USE_INSTANCING\n            mat3 m = mat3( im );\n            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n            transformedNormal = m * transformedNormal;\n          #endif\n          transformedNormal = normalMatrix * transformedNormal;\n          #ifdef FLIP_SIDED\n            transformedNormal = - transformedNormal;\n          #endif\n          #ifdef USE_TANGENT\n            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n            #ifdef FLIP_SIDED\n              transformedTangent = - transformedTangent;\n            #endif\n          #endif\n          #ifndef FLAT_SHADED\n            vNormal = normalize( transformedNormal );\n            #ifdef USE_TANGENT\n              vTangent = normalize( transformedTangent );\n              vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n            #endif\n          #endif\n        #endif\n      `)\n\n      shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', `\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        #ifdef USE_INSTANCING\n          mvPosition = im * mvPosition;\n        #endif\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n      `)\n\n      shader.fragmentShader = `\n        varying float vMapIndex;\n      ` + shader.fragmentShader\n      shader.fragmentShader = shader.fragmentShader.replace('#include <map_fragment>', `\n        #ifdef USE_MAP\n          vec2 uv = vUv;\n          uv.x = (vMapIndex + vUv.x) / TEXTURE_COUNT;\n          vec4 sampledDiffuseColor = texture2D(map, uv);\n          diffuseColor *= sampledDiffuseColor;\n        #endif\n      `)\n    }\n\n    switch (config.material) {\n      case 'standard' :\n        material = new MeshStandardMaterial(materialParams)\n        break\n      case 'phong' :\n        material = new MeshPhongMaterial(materialParams)\n        break\n      default :\n        material = new MeshBasicMaterial(materialParams)\n    }\n\n    iMesh = new InstancedMesh(geometry, material, COUNT)\n    setColors(config.colors)\n    scene.add(iMesh)\n  }\n\n  function setColors (colors) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const cscale = colorScale(colors)\n      for (let i = 0; i < COUNT; i++) {\n        iMesh.setColorAt(i, cscale.getColorAt(i / COUNT))\n      }\n      iMesh.instanceColor.needsUpdate = true\n    }\n  }\n\n  /**\n   */\n  function initTextures (texturePosition, textureVelocity) {\n    const dummy = new Vector3()\n    const posArray = texturePosition.image.data\n    const velArray = textureVelocity.image.data\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      dummy.set(rndFS(1), rndFS(1), rndFS(1)).normalize().multiplyScalar(rndFS(config.attractionRadius1 * 2)).toArray(posArray, k)\n      posArray[k + 3] = rnd(0.1, 1)\n\n      dummy.set(rndFS(1), rndFS(1), rndFS(1)).normalize().multiplyScalar(rndFS(0.5)).toArray(velArray, k)\n      velArray[k + 3] = 0\n    }\n  }\n}\n"],"names":["commonConfig","defaultConfig","three","colors","rnd","rndFS","psrdnoise","camera"],"mappings":"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"}